## Raft 协议简介

  在单个服务器上的单个进程中维护状态很容易。你的过程是一个单一的权威点，所以在读写状态时没有冲突。即使多线程进程也可以依赖于锁或协程来串行化对数据的访问。

  然而，在分布式系统中，没有单一的权威点。服务器可能崩溃或两台机器之间的网络可能变得不可用或可能发生任何数量的其他问题。

  分布式一致性协议用于在群集中的多个服务器上维持一致的状态。许多分布式系统是建立在Paxos协议上的，但是Paxos可能很难理解，并且Paxos和真实世界实现之间有很多差距。

  一种替代方案是由Diego Ongaro和John Ousterhout的Raft分布式共识协议。 Raft是一个以可理解性作为主要原则构建的协议，它围绕两件事情：
  
- Leader Election
- Replicated Log

使用这两个构造，您可以构建一个可以跨多个服务器维护状态的系统，即使在发生多个故障的情况下也是如此。

####Leader Election
Raft协议有效地作为主从系统工作，从而将状态变化写入集群中的单个服务器，并且分布到集群中的其余服务器。 这简化了协议，因为只有一个数据权威，并且不必解决冲突。

Raft确保每次只有一个领导。 它通过在集群中的节点之间执行选举并且要求节点必须接收大多数票以成为领导者来做到这一点。 例如，如果您的集群中有3个节点，则单个节点需要2票才能成为领导者。 对于5节点集群，服务器需要3票才能成为领导者。

####Replicated Log
为了维持状态，维护命令的日志。 每个命令都会更改服务器的状态，并且该命令是确定性的。 通过确保此日志在集群中的所有节点之间相同地被复制，我们可以通过顺序地运行每个命令来在日志中的任何时间点复制状态。

在正常条件下复制日志是通过从领导者发送AppendEntries RPC到集群中的每个其他服务器（称为对等体）来完成的。 每个对等体将通过两阶段提交过程来附加来自领导者的条目，这确保集群中的大多数服务器具有写入日志的条目。

####介绍
在raft集群中, raft节点有且仅有一下三种状态中的一种 – – follower, candidate 或 leader.  所有节点启动时状态都是follower. 在此状态下节点能够接收来自leader的日志并投票.  如果一段时间内没有接收到来自leader的消息则节点状态自动升级为candidate, 处于candidate状态的节点请求来自其对等体的投票. 如果候选者获得需要的票数则状态升级为leader, leader必须接受新的日志条目, 并复制给所有的follower. 另外如果follower的日志和leader的冲突, 则所有的查询也必须对leader执行.(集群正常时可以对所有节点执行查询操作, 但只能对leader执行写操作).

一个raft集群中只有一个leader, 他能接收新的日志条目, 客户端能够请求leader住家新的日志条目. leader会尝试将新的日志条目写入持久化存储, 并复制给所有合法的follower. 一旦认为日志条目已提交，就可以将其应用于有限状态机。 有限状态机是特定于应用的，并且使用接口来实现.
    
一个明显的问题与复制日志的无限性质有关。 Raft提供了一种机制，通过该机制快照当前状态，并压缩日志。 由于FSM抽象，恢复FSM的状态必须导致与旧日志的重放相同的状态。 这允许Raft在某个时间点捕获FSM状态，然后删除用于达到该状态的所有日志。 这是自动执行的，无需用户干预，并可防止无限制的磁盘使用，以及最大限度地减少重播日志所需的时间.

当新服务器加入或现有服务器离开时，存在更新对等集的问题。 只要法定数量的节点可用，这不是一个问题，因为Raft提供了动态更新对等集的机制。 如果一个法定数量的节点不可用，这将成为一个非常具有挑战性的问题。 例如，假设只有2个对等体A和B.仲裁大小也是2，这意味着两个节点必须同意提交日志条目。 如果A或B失败，现在不可能达到法定人数。 这意味着集群无法添加，删除节点或提交任何其他日志条目。 这导致不可用。 此时，需要手动干预以删除A或B，并在引导模式下重新启动剩余的节点.

3个节点的Raft集群可以容忍单个节点故障，而5个集群可以容忍2个节点故障。 推荐的配置是运行3或5 raft服务器。 这将最大限度地提高可用性，而不会大大牺牲性能.

在性能方面，Raft与Paxos相当。 假设稳定的领导，提交日志条目需要单次往返一半的集群。 因此，性能受磁盘I / O和网络延迟的约束。
